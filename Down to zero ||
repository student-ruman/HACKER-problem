#include <stdio.h>
#include <math.h>
#include <limits.h>

// Max value of N is 1,000,000. We need an array to store results up to this value.
#define MAX_N 1000001

int dp[MAX_N];

// Function to precompute the minimum moves for all numbers up to MAX_N
void precompute_min_moves() {
    // Initialize dp array.
    // Setting dp[i] = i is a valid starting point because decrementing
    // by one i times is always an option.
    for (int i = 0; i < MAX_N; i++) {
        dp[i] = i;
    }

    // dp[0] is 0 moves to go from 0 to 0.
    dp[0] = 0;
    // For n=1, 2, 3, it takes n moves.
    dp[1] = 1;

    // Iterate through all numbers from 2 up to the maximum.
    for (int i = 2; i < MAX_N; i++) {
        // Option 1: Decrement by one. The moves would be 1 + moves(i-1).
        // Update dp[i] if this is a better option.
        if (dp[i] > 1 + dp[i-1]) {
            dp[i] = 1 + dp[i-1];
        }

        // Option 2: Factorization.
        // For every factor of `i`, you can transition to the larger factor.
        // We only need to check for factors up to the square root of i.
        for (int j = 2; j * j <= i; j++) {
            if (i % j == 0) {
                // The factors are j and i/j. The next number is max(j, i/j), which is i/j.
                int larger_factor = i / j;
                if (dp[i] > 1 + dp[larger_factor]) {
                    dp[i] = 1 + dp[larger_factor];
                }
            }
        }
    }
}

int main() {
    // Precompute all values once before processing any queries.
    precompute_min_moves();

    int Q;
    scanf("%d", &Q);

    while (Q--) {
        int N;
        scanf("%d", &N);
        printf("%d\n", dp[N]);
    }

    return 0;
}
